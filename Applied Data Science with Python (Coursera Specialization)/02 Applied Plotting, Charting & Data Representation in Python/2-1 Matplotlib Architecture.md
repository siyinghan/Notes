# 2-1 Matplotlib Architecture

We're going to use matplotlib within the Jupyter Notebook, just like with did with pandas. Jupyter has some specialized support for matplotlib and this is enabled by using the `IPython` magic `%matplotlib notebook`. Remember that in the Jupyter Notebook, the `IPython` magics are just helper functions which set up the environment so that the web based rendering can be enabled.

<img src='https://github.com/siyinghan/Notes/raw/master/Applied%20Data%20Science%20with%20Python%20(Coursera%20Specialization)/02%20Applied%20Plotting%2C%20Charting%20%26%20Data%20Representation%20in%20Python/Image/034.png' alt='034' width='80%' />

`matplotlib` itself can work well outside of the Jupyter environment. But for this course, we're going to focus on its use within the web environment in part because of how popular Jupyter has become in data science practice. So what actually has happened when you run the magic function matplotlib with the inline parameter, is that matplotlib is configured to render into the browser. This configuration is called a **backend**, and matplotlib has a number of different backends available. A backend is an abstraction layer which knows how to interact with the operating environment, whether it's an operating system, or an environment like the browser, and knows how to render matplotlib commands. In fact, there's a number of different interactive backends, but there are also backends called **hard copy backends**, which support rendering to graphics formats, like scalable vector graphics, SVGs, or PNGs. So not all backends support all features, especially interactive features, which we'll touch on later in this course.

```python
%matplotlib notebook
```

Let's import the matplotlib library, which we'll do as mpl, and call get backend to make sure we're using the NbAgg backend. Great, you'll notice that matplotlib has a lot of non-Pythonic naming conventions. In particular, you'll be accessing variables using the **Get** and **Set**. Which is an accessor pattern which is more common in languages like Java. This is just something you have to get used to, but remember you can hit Tab for type hint autocompletion in the Jupyter Notebook. So this can help you find the functions that you're looking for. Now we're not going to spend much time with the backend layer, but it's important to be aware of. If you're on Mac OS, for instance, your default backend when using matplotlib is one system. While on Linux, GTK is my default backend. The next layer is where we'll spend most of our time though, and that's called the artist layer. The artist layer is an abstraction around drawing and layout primitives. The root of visuals is a set of containers which includes a figure object with one or more subplots, each with a series of one or more axes. This last object, the axes is the most common one you'll interact with, changing the range of a given axis or plotting shapes to it. And just a brief aside, especially since this is a global classroom with people from around the world enrolled where English might not be their first language, matplotlib relies heavily on the axes object, which is the plural form of axis. But matplotlib also has an axis object as well. And an axes is actually made up of two axis objects. One for the x, horizontal dimension. And one for the y, or vertical dimension. So you might hear me pronouncing these two words, axes and axis a bit more intentionally than I would in regular speech in order to help make things easier to follow. The artist layer also contains primitives and collections. These are base drawing items, things like a rectangle, ellipse or a line. And collections of items, such as a path, which might capture many lines together into a polygon shape. Collections are easy to recognize as their name tends to end in the word collection. It's worth taking a moment to look at the kinds of artists which are available.

<img src='https://github.com/siyinghan/Notes/raw/master/Applied%20Data%20Science%20with%20Python%20(Coursera%20Specialization)/02%20Applied%20Plotting%2C%20Charting%20%26%20Data%20Representation%20in%20Python/Image/035.png' alt='035' width='100%' />

Here's an image from the matplotlib documentation on artists. You'll see that there's lots of child objects of the artists object, and that one of them is called **patches.patch**. This name comes from the matlab roots of the project. And a patch is any two-dimensional object which has a face color and an edge color. And children of the patch class are the primitives, as we've discussed.

<img src='https://github.com/siyinghan/Notes/raw/master/Applied%20Data%20Science%20with%20Python%20(Coursera%20Specialization)/02%20Applied%20Plotting%2C%20Charting%20%26%20Data%20Representation%20in%20Python/Image/036.png' alt='036' width='80%' />

Okay, so `matplotlib` has two layers:

* A **backend layer**, which knows about low level graphics routines it can render to the screen or to a file. We'll use the inline backend for most of our work.
* And the **artist layer**, which describes primitives, collections, and containers. It knows how figures are composed of subfigures and where objects are in a given axes coordinate system.

So with this, we can actually get started building figures and rendering them. But there's one more layer which is extremely important for us as data scientists in particular, and this is called **the scripting layer**. You see, if we were writing an application to use matplotlib, we might never care about the scripting layer. But this layer helps simplify and speed up our interaction with the environment in order to build plots quickly. It does this, frankly, by doing a bunch of magic for us. And the difference between someone who is effective with matplotlib and someone who isn't, is usually based on their understanding of this magic of the scripting layer. The scripting layer we use in this course is called `pyplot`. So that describes the matplotlib layer cake.

There's a **backend**, which deals with actual drawing. **A bunch of artists** on top of the backend, which describe how data is arranged. And a **scripting layer**, which actually creates those artists and choreographs them all together.

I just want to address one more topic before we move on, and that's the difference between procedural and declarative visualization libraries and, well, user interfaces more generally:

* The `pyplot` **scripting layer** is a **procedural method** for building a visualization, in that we tell the underlying software which drawing     actions we want it to take in order to render our data.
* There are also **declarative methods** for visualizing data. **HTML** is a great example of this. Instead of issuing command after command to the backend rendering agent, which is the browser with HTML, HTML documents are formatted as models of relationships in a document, often called the **DOM**, or Document Object Model. These are two fundamentally different ways of creating and representing graphical interfaces. The popular `JavaScript` library, for instance, D3.JS is an example of a declarative information visualization method. While matplotlib's pyplot is an example of a procedural information visualization method.

